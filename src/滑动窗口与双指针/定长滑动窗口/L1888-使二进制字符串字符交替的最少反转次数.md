# 1888. 使二进制字符串字符交替的最少反转次数

给你一个二进制字符串 `s` 。你可以按任意顺序执行以下两种操作任意次：

*   **类型 1 ：删除**  字符串 `s` 的第一个字符并将它 **添加**  到字符串结尾。
*   **类型 2 ：选择**  字符串 `s` 中任意一个字符并将该字符 **反转**  ，也就是如果值为 `'0'` ，则反转得到 `'1'` ，反之亦然。

请你返回使 `s` 变成 **交替**  字符串的前提下， **类型 2**  的 **最少**  操作次数 。

我们称一个字符串是 **交替**  的，需要满足任意相邻字符都不同。

*   比方说，字符串 `"010"` 和 `"1010"` 都是交替的，但是字符串 `"0100"` 不是。

**示例 1：**

> **输入：** s = "111000"
> 
> **输出：** 2
> 
> **解释：** 执行第一种操作两次，得到 s = "100011" 。
> 
> 然后对第三个和第六个字符执行第二种操作，得到 s = "10**1** 01**0** " 。
>

**示例 2：**

> **输入：** s = "010"
> 
> **输出：** 0
> 
> **解释：** 字符串已经是交替的。
>

**示例 3：**

> **输入：** s = "1110"
> 
> **输出：** 1
> 
> **解释：** 对第二个字符执行第二种操作，得到 s = "1**0** 10" 。
>

**提示：**

*   `1 <= s.length <= 10^5`
*   `s[i]` 要么是 `'0'` ，要么是 `'1'` 。

## 题解

```java
public int minFlips(String s) {
    char[] chars = s.toCharArray();

    int    count = 0, ans = Integer.MAX_VALUE;
    char[] map   = new char[]{'0', '1'};
    int n = chars.length;

    for (int i = 0; i < n * 2; i++) {
        // 先假设按照 010101.... 的顺序排列，计算需要修改的顺序
        if (chars[i % n] != map[i % 2]) {
            count++;
        }
        if (i < n - 1) {
            continue;
        }
        // 这里为什么要比较 n - count?
        // 可以自己推演一下 01100 按照 01 的顺序，需要改 2 位，按照 10 的顺序就需要改 3 位
        ans = Math.min(ans, Math.min(count, n - count));
        if (ans == 0) {
            return 0;
        }
        // 这里为什么要将 count 改为 n - count?
        // 假设是 01100，第一轮修改完后，需要将 0 移动到末尾，其实可以理解为中间的 1100 是不需要动的
        // 而 1100 再按照 01 的顺序排序，刚好需要 n - count 位
        count = n - count;
    }
    return ans;
}
```